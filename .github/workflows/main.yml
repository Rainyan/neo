name: CI

on:
  push:
    branches: [ build_test_win ]
  pull_request:
    branches: [ build_test_win ]
    types: [ synchronize ]

jobs:
  build:
    strategy:
      matrix:
        os: [ windows-latest ]

    runs-on: ${{ matrix.os }}
    env:
      POWERSHELL_TELEMETRY_OPTOUT: 1
    
    steps:
    # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
    - uses: actions/checkout@v2
            
    - name: Install Microsoft Speech SDK 5.1
      env:
        SPEECH_SDK_URL: https://download.microsoft.com/download/B/4/3/B4314928-7B71-4336-9DE7-6FA4CF00B7B3/SpeechSDK51.exe
        SPEECH_SDK_NAME: SpeechSDK51
        SPEECH_SDK_PRODUCT_NAME: Microsoft Speech SDK 5.1
        SPEECH_SDK_CONTAINED_INSTALLER: Microsoft Speech SDK 5.1.msi
        SPEECH_SDK_INSTALL_LOCATION: C:\Program Files (x86)\Microsoft Speech SDK 5.1
        SPEECH_SDK_PATCH_URL: https://gist.githubusercontent.com/Rainyan/6ac519c7257b54f45546c0864adc1cb0/raw/9c8444790c53365a3143accb26851cb3dbb574ac
        SPEECH_SDK_PATCH_FILE: fix_speechsdk_syntax.patch
      run: |    
        if (0) { echo "Skipping step."; return }
        
        echo("Downloading ${env:SPEECH_SDK_PRODUCT_NAME}")
        Invoke-WebRequest ${env:SPEECH_SDK_URL} -OutFile ".\${env:SPEECH_SDK_NAME}.exe"
        
        echo("Verifying download integrity")
        # Based on https://devblogs.microsoft.com/scripting/reporting-on-digitally-signed-files-with-powershell/
        Function Expand-AuthenticodeSignature($AuthenticodeSignature)
        {
          $AuthenticodeSignature | Select-object -Property Path, `
            Status,StatusMessage,SignatureType, `
            @{Name=’SubjectName’;Expression={($_.SignerCertificate.Subject)}}, `
            @{Name=’SubjectIssuer’;Expression={($_.SignerCertificate.Issuer)}}, `
            @{Name=’SubjectSerialNumber’;Expression={($_.SignerCertificate.SerialNumber)}}, `
            @{Name=’SubjectNotBefore’;Expression={($_.SignerCertificate.NotBefore)}}, `
            @{Name=’SubjectNotAfter’;Expression={($_.SignerCertificate.NotAfter)}}, `
            @{Name=’SubjectThumbprint’;Expression={($_.SignerCertificate.ThumbPrint)}}, `
            @{Name=’TimeStamperName’;Expression={($_.SignerCertificate.Subject)}}, `
            @{Name=’TimeStamperIssuer’;Expression={($_.SignerCertificate.Issuer)}}, `
            @{Name=’TimeStamperSerialNumber’;Expression={($_.SignerCertificate.SerialNumber)}}, `
            @{Name=’TimeStamperNotBefore’;Expression={($_.SignerCertificate.NotBefore)}}, `
            @{Name=’TimeStamperNotAfter’;Expression={($_.SignerCertificate.NotAfter)}}, `
            @{Name=’TimeStamperThumbprint’;Expression={($_.SignerCertificate.ThumbPrint)}}
        }
        
        $speechSdkSig = Expand-AuthenticodeSignature -AuthenticodeSignature (Get-ChildItem "${env:SPEECH_SDK_NAME}.exe" | Get-AuthenticodeSignature)

        # Need to match this digital signature.
        $sigRequirements = @{
          "Status" = "Valid";
          "StatusMessage" = "Signature verified.";
          "SignatureType" = "Authenticode";
          "SubjectName" = "CN=Microsoft Corporation, OU=Copyright (c) 2001 Microsoft Corp., O=Microsoft Corporation, L=Redmond, S=Washington, C=US";
        }

        foreach ($requirement in $sigRequirements.GetEnumerator()) {  
          $reqName = $requirement.Name
          $reqValue = $requirement.Value
          $sigValue = $speechSdkSig.$reqName
          if (-Not ($reqValue -eq $sigValue)) {
            throw "Digital signature mismatched value of $reqName (was `"${sigValue}`" but expected `"${reqValue}`")"
          }
        }
        echo "${env:SPEECH_SDK_PRODUCT_NAME} passed digital signature checks."
        
        echo("Unarchiving ${env:SPEECH_SDK_PRODUCT_NAME} installer")
        # We can interpret this self-extracting executable as a zip archive.
        Rename-Item -Path ".\${env:SPEECH_SDK_NAME}.exe" -NewName ".\${env:SPEECH_SDK_NAME}.zip"
        $unZipDir = "$pwd" + "\${env:SPEECH_SDK_NAME}_files"
        Expand-Archive -Path ".\${env:SPEECH_SDK_NAME}.zip" -DestinationPath "${unZipDir}"
        
        echo("Installing ${env:SPEECH_SDK_PRODUCT_NAME}")
        $logFile = "msiexec.log"
        echo "Installer full path: `"${unZipDir}\${env:SPEECH_SDK_CONTAINED_INSTALLER}`""
        echo "Log full path: `"${unZipDir}\${logFile}`""
        # Pipe to null to wait for installation to finish before continuing.
        msiexec /i "${unZipDir}\${env:SPEECH_SDK_CONTAINED_INSTALLER}" /norestart /passive /l*v "${unZipDir}\${logFile}" | Out-Null
        
        # Check if the install was successful by parsing the msiexec log file.
        $msiLog = Get-Content "${unZipDir}\${logFile}"
        # Looking for a line with this pattern.
        $msiLogCompletionLine = "Windows Installer installed the product."
        $msiResultLine = Select-String -Path "${unZipDir}\${logFile}" -Pattern $msiLogCompletionLine
        if (!$msiResultLine) {
          throw "MSI log was missing the required pattern: `"${msiLogCompletionLine}`""
        }
        # Line should end with this pattern specifying the MSI exit code 0.
        $msiSuccessPattern = ": 0."
        $msiResultStr = $msiResultLine.ToString().Trim()
        $msiResultSubstr = $msiResultStr.Substring($msiResultStr.Length - $msiSuccessPattern.Length)
        $msiInstallSuccess = ($msiResultSubstr -eq $msiSuccessPattern)
        if (!$msiInstallSuccess) {
          echo "Failed to find the required pattern; dumping log of `"${installerFullPath}\${logFile}`":"
          Get-Content "${installerFullPath}\${logFile}"
          throw "MSI success != true; exitcode substring returned ${msiResultSubstr} (this may not be the actual full exit code)"
        } else {
          echo "${env:SPEECH_SDK_PRODUCT_NAME} MSI was successful"
        }
        
        echo "Correcting ${env:SPEECH_SDK_PRODUCT_NAME} include syntax"
        cd "${env:SPEECH_SDK_INSTALL_LOCATION}"
        Invoke-WebRequest "${env:SPEECH_SDK_PATCH_URL}/${env:SPEECH_SDK_PATCH_FILE}" -OutFile ".\${env:SPEECH_SDK_PATCH_FILE}"
        git apply --check --verbose --summary ".\${env:SPEECH_SDK_PATCH_FILE}"
        git apply ".\${env:SPEECH_SDK_PATCH_FILE}"
        
        echo "Symlinking ${env:SPEECH_SDK_PRODUCT_NAME} includes"
        New-Item -ItemType Junction -Path . -Name "sapi51" -Target "${env:SPEECH_SDK_INSTALL_LOCATION}"
        
    - name: Install Microsoft Visual Studio Community 2013 with Update 5 and MFC
      env:
        PRODUCT_URL_BASE: https://download.microsoft.com/download/A/A/D/AAD1AA11-FF9A-4B3C-8601-054E89260B78
        PRODUCT_NAME_BASE: vs_community
        PRODUCT_FULL_NAME: Microsoft Visual Studio Community 2013 with Update 5
        PRODUCT_BASE_INSTALL_PATH: C:\Program Files (x86)\MSBuild\12.0\Bin
      run: |
        if (1) { echo "Skipping step."; return }
        
        echo("Downloading ${env:PRODUCT_FULL_NAME}")
        mkdir ".\${env:PRODUCT_NAME_BASE}_files"
        $installerPath = "$pwd" + "\${env:PRODUCT_NAME_BASE}_files"
        Invoke-WebRequest "${env:PRODUCT_URL_BASE}/${env:PRODUCT_NAME_BASE}.exe" -OutFile "${installerPath}\${env:PRODUCT_NAME_BASE}.exe"
        
        echo("Verifying download integrity")
        # Based on https://devblogs.microsoft.com/scripting/reporting-on-digitally-signed-files-with-powershell/
        Function Expand-AuthenticodeSignature($AuthenticodeSignature)
        {
          $AuthenticodeSignature | Select-object -Property Path, `
            Status,StatusMessage,SignatureType, `
            @{Name=’SubjectName’;Expression={($_.SignerCertificate.Subject)}}, `
            @{Name=’SubjectIssuer’;Expression={($_.SignerCertificate.Issuer)}}, `
            @{Name=’SubjectSerialNumber’;Expression={($_.SignerCertificate.SerialNumber)}}, `
            @{Name=’SubjectNotBefore’;Expression={($_.SignerCertificate.NotBefore)}}, `
            @{Name=’SubjectNotAfter’;Expression={($_.SignerCertificate.NotAfter)}}, `
            @{Name=’SubjectThumbprint’;Expression={($_.SignerCertificate.ThumbPrint)}}, `
            @{Name=’TimeStamperName’;Expression={($_.SignerCertificate.Subject)}}, `
            @{Name=’TimeStamperIssuer’;Expression={($_.SignerCertificate.Issuer)}}, `
            @{Name=’TimeStamperSerialNumber’;Expression={($_.SignerCertificate.SerialNumber)}}, `
            @{Name=’TimeStamperNotBefore’;Expression={($_.SignerCertificate.NotBefore)}}, `
            @{Name=’TimeStamperNotAfter’;Expression={($_.SignerCertificate.NotAfter)}}, `
            @{Name=’TimeStamperThumbprint’;Expression={($_.SignerCertificate.ThumbPrint)}}
        }
        
        $productSig = Expand-AuthenticodeSignature -AuthenticodeSignature (Get-ChildItem "${installerPath}\${env:PRODUCT_NAME_BASE}.exe" | Get-AuthenticodeSignature)
        
        # Need to match this digital signature.
        $sigRequirements = @{
          "Status" = "Valid";
          "StatusMessage" = "Signature verified.";
          "SignatureType" = "Authenticode";
          "SubjectName" = "CN=Microsoft Corporation, OU=MOPR, O=Microsoft Corporation, L=Redmond, S=Washington, C=US";
        }
        
        foreach ($requirement in $sigRequirements.GetEnumerator()) {  
          $reqName = $requirement.Name
          $reqValue = $requirement.Value
          $sigValue = $productSig.$reqName
          if (-Not ($reqValue -eq $sigValue)) {
            throw "Digital signature mismatched value of $reqName (was `"${sigValue}`" but expected `"${reqValue}`")"
          }
        }
        echo "${env:PRODUCT_FULL_NAME} installer passed digital signature checks."
        
        echo("Installing ${env:PRODUCT_FULL_NAME}")
        echo "Launching `"${installerPath}\${env:PRODUCT_NAME_BASE}.exe`""
        & "${installerPath}\${env:PRODUCT_NAME_BASE}.exe"
        $wshell = New-Object -ComObject "WScript.Shell"
        echo "Waiting for installer"
        # Just wait until reasonably confident the installer should be ready
        Sleep 60
        # Grab the installer active window
        $installerWindowTitle = "Community 2013"
        $wshell.AppActivate($installerWindowTitle)
        Sleep 1
        # Navigate the installer first page keypresses
        $wshell.SendKeys("`t `t `t`n")
        Sleep 10
        $wshell.AppActivate($installerWindowTitle)
        Sleep 1
        # Navigate second page keypresses.
        # Deselect all additional payloads.
        $wshell.SendKeys("`t`t `t`t`t`t`t`t")
        # Need this for arrow down input.
        [void][System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms")
        Sleep 1
        [System.Windows.Forms.SendKeys]::SendWait("{DOWN}")
        Sleep 1
        # Include the MFC to install, and begin installation.
        $wshell.SendKeys(" `t`t`t`t`n")
        echo "Installing..."
        
        # We're happy with MD5 because we only use it for file integrity checks; the installer
        # we're checking against has already passed a cert check.
        $integrityAlgo = "MD5"
        
        # Helper function for populating the reference array.
        function AddReference($hash, $path)
        {
          $item = New-Object psobject
          $item | Add-Member -type NoteProperty -Name "Algorithm" -Value "$integrityAlgo"
          $item | Add-Member -type NoteProperty -Name "Hash" -Value "$hash"
          $item | Add-Member -type NoteProperty -Name "Path" -Value "${env:PRODUCT_BASE_INSTALL_PATH}\${path}"
          return $item
        }
        
        # Compare hashes to the reference, and return whether they are equal.
        function IsCompareEqualToReference($reference, $compare)
        {
          # Compare is allowed to be empty (ie. got nothing to compare), but the reference must exist.
          if (!$reference) {
            throw "Reference was null"
          }
          if (-Not $reference.Length -eq $compare.Length) {
            return $FALSE
          }
          $numMatches = 0
          foreach ($thisReference in $reference) {
            :inner foreach ($thisCompare in $compare) {
              if (-Not $thisReference.Path -eq $thisCompare.Path) {
                continue
              }
              if (-Not $thisReference.Algorithm -eq $thisCompare.Algorithm) {
                throw "Algorith mismatch ($thisReference.Algorithm vs. $thisCompare.Algorithm)"
              }
              if (-Not $thisReference.Hash -eq $thisCompare.Hash) {
                echo "Hash mismatch ($thisReference.Hash vs. $thisCompare.Hash)"
              } else {
                $numMatches++
              }
              break inner
            }
          }
          return ($numMatches -eq $reference.Length)
        }
        
        # Array of reference file hashes we expect to find at PRODUCT_BASE_INSTALL_PATH on a finished installation.
        $reference = @()
        $reference += AddReference "6CDFA59B410E8873F811C4BFFE136F99" "alink.dll"
        $reference += AddReference "5781757B98D4CC6D3F480BC71166EB50" "csc.exe"
        $reference += AddReference "C002006CED9DE9EDDDD0FBC440A33623" "csc.exe.config"
        $reference += AddReference "5078D659DE71EE8CACEC46D0DE25E9E0" "csc.rsp"
        $reference += AddReference "A19A2658BA69030C6AC9D11FD7D7E3C1" "default.win32manifest"
        $reference += AddReference "9869F289E0261E45A2DAE189975D33E9" "FileTracker.dll"
        $reference += AddReference "9D50746FC523CB3E3BCE14A1AFE686BE" "License.htm"
        $reference += AddReference "36877D5E575806828C96A8BA368CB7D9" "Microsoft.Build.Conversion.v12.0.dll"
        $reference += AddReference "422AE7CF0D74067CAF71C7000E6418AA" "Microsoft.Build.dll"
        $reference += AddReference "4AE5C6D6318D4EA1A743CFC0C382D38A" "Microsoft.Build.Engine.dll"
        $reference += AddReference "0EBD75453E7EF51A0325C309813AF5A1" "Microsoft.Build.Framework.dll"
        $reference += AddReference "5F40EF6462BB201BAE66942B3875F348" "Microsoft.Build.Tasks.v12.0.dll"
        $reference += AddReference "E194B781BBB12D3419BF9046F87E67A2" "Microsoft.Build.Utilities.v12.0.dll"
        $reference += AddReference "D6761B31ACFDB6299229C4DCE9755C75" "Microsoft.Common.CurrentVersion.targets"
        $reference += AddReference "E00BB9755D1AC4ED3A07DF9DA5B5DD0E" "Microsoft.Common.overridetasks"
        $reference += AddReference "601BCA1A89025557DE5F83FC8E568FDC" "Microsoft.Common.targets"
        $reference += AddReference "CB999A07BA9108024274E8D5ABB68B8B" "Microsoft.Common.tasks"
        $reference += AddReference "2DB919DE22205FD34F2AC3F69BFD8BF1" "Microsoft.CSharp.CurrentVersion.targets"
        $reference += AddReference "57F7BBE3394A011533D28D6940914367" "Microsoft.CSharp.targets"
        $reference += AddReference "07490CBE0DD4982A6D5C85BBCFCC7D8C" "Microsoft.Data.Entity.targets"
        $reference += AddReference "54AEA08B0626DA4951F2C5DB633A2F01" "Microsoft.NetFramework.CurrentVersion.props"
        $reference += AddReference "2AF6302971A1DC8922D1BC71C166234D" "Microsoft.NetFramework.CurrentVersion.targets"
        $reference += AddReference "038E070A993E62A55E391FA71B13277C" "Microsoft.NetFramework.props"
        $reference += AddReference "A31C39592062C714EBAEA6065AA9BEF1" "Microsoft.NetFramework.targets"
        $reference += AddReference "214B49AAD63730C0AD497DDFFE1CA3B8" "Microsoft.ServiceModel.targets"
        $reference += AddReference "AF9CF99669399F7F73096FE83CDD5DDD" "Microsoft.VisualBasic.CurrentVersion.targets"
        $reference += AddReference "33271FB54111743E37BA41174D722346" "Microsoft.VisualBasic.targets"
        $reference += AddReference "FFACE2C375FB88C296270132C729F8DB" "Microsoft.WinFx.targets"
        $reference += AddReference "20EE40C3D11DA23776EE02E0FBE18790" "Microsoft.WorkflowBuildExtensions.targets"
        $reference += AddReference "9355486A2710ACE0ED03F5CECFAE69B9" "Microsoft.Xaml.targets"
        $reference += AddReference "A229105148A47CBC0BE544931A71A09B" "MSBuild.exe"
        $reference += AddReference "70A5EE423BAFDACC155EA564872CA412" "MSBuild.exe.config"
        $reference += AddReference "DC62688854FAC06CDEBD121C95D48E01" "MSBuild.rsp"
        $reference += AddReference "A7D33E375513D7B0219FA07969F9AC9C" "MSBuildTaskHost.exe"
        $reference += AddReference "C9DB610D35202B83DAE4AC19C8DB4471" "MSBuildTaskHost.exe.config"
        $reference += AddReference "309DC807F102D9B16D004E9A6E3A8F9A" "Tracker.exe"
        $reference += AddReference "2B9DF837DE8C54842D3CABD036B24000" "vbc.exe"
        $reference += AddReference "C002006CED9DE9EDDDD0FBC440A33623" "vbc.exe.config"
        $reference += AddReference "2F7F2432CC38563B16A3BB7ACA8F7863" "vbc.rsp"
        $reference += AddReference "39C82AC5CD2696DEB3B436B8BF09C952" "Workflow.targets"
        $reference += AddReference "EFFF1B2DEA1495426AA319D374F6B065" "Workflow.VisualBasic.targets"
        
        $installerFinished = $FALSE
        $installerWaitIntervalSeconds = 60
        $numFails = 0
        # Try at most this many times with the above intervals, then give up and throw error.
        # Set to 0 to never give up (possible to go infinitely idle on installer failure state, bar runner timeout).
        $maxFails = 10
        Do {
          # Get the actual hashes we currently have.
          $compare = @()
          if (Test-Path -Path "${env:PRODUCT_BASE_INSTALL_PATH}") {
            Get-ChildItem -File "${env:PRODUCT_BASE_INSTALL_PATH}" | ForEach-Object {
              $compare += Get-FileHash -Algorithm "$integrityAlgo" $_.FullName
            }
          }
          
          $installerFinished = (IsCompareEqualToReference $reference $compare)
          if (-not($installerFinished)) {
            $numFails++
            if ($numFails -eq $maxFails) {
              throw "Hash check reached max wait time fails; aborting"
            }
            echo "Waiting for installer to finish"
            Sleep $installerWaitIntervalSeconds
          }
        } While (-not($installerFinished))
        
        # Wait for IO data to complete before continuing.
        $numFails = 0
        $maxFails = 40
        $numIOSuccesses = 0
        $numIOSuccessesToContinue = 10
        $installerWaitIntervalSeconds = 30
        Do {
          $loopNumSuccesses = 0
          # 2 procs that we iterate; need both to succceed
          $expectedLoopNumSuccesses = 2
          Get-Process "${env:PRODUCT_NAME_BASE}" | ForEach-Object {
            $id = $_.Id
            $perfProc = Get-CimInstance Win32_PerfFormattedData_PerfProc_Process | ? { $_.IDProcess -eq $id }
            if (!$perfProc) {
              throw "Couldn't get perfproc"
            }
            if ($perfProc.IODataOperationsPersec -eq 0) {
              $loopNumSuccesses++
              $numFails = 0
            } else {
              echo "Installer data io: $($perfProc.IODataOperationsPersec)"
            }
          }
          
          While (Get-Process -ErrorAction SilentlyContinue "devenv") {
            echo "Waiting for devenv setup"
            Sleep $installerWaitIntervalSeconds
          }
          
          if ($loopNumSuccesses -eq $expectedLoopNumSuccesses) {
            $numIOSuccesses++
            echo "${numIOSuccesses}/${numIOSuccessesToContinue}"
          } else {
            $numFails++
            $numIOSuccesses = 0
            if ($numFails -eq $maxFails) {
              throw "IO check reached max wait time fails; aborting"
            }
            echo "Waiting for data IO to finish"
          }
          Sleep $installerWaitIntervalSeconds
        } While (-not($numIOSuccesses -eq $numIOSuccessesToContinue))
        echo "IO data finished"
        
        # Ask to close the installer.
        echo "Preparing to close the installer"
        $wshell.AppActivate($installerWindowTitle)
        Sleep 1
        $wshell.SendKeys("`t`n")
        Sleep $installerWaitIntervalSeconds
        
        # todo: fix me
        if (0) {
        
        # See if we've actually closed.
        $numInstallerCloseTries = 0
        $maxInstallerCloseTries = 20
        $installerProc = Get-Process -ErrorAction SilentlyContinue "${env:PRODUCT_NAME_BASE}"
        Do {
          Sleep $installerWaitIntervalSeconds
          # The installer will launch VS when it's done, so we're trying to catch that as sign we're ready to close.
          $vsProc = Get-Process -ErrorAction SilentlyContinue "devenv"
          if ($vsProc) {
            # We got the VS process, now close it.
            $vsProc.CloseMainWindow()
            Sleep 10
            $vsProc = Get-Process -ErrorAction SilentlyContinue "devenv"
            if ($vsProc) {
              $vsProc | Stop-Process -Force
              Sleep 10
              $vsProc = Get-Process -ErrorAction SilentlyContinue "devenv"
              if ($vsProc) {
                throw "Failed to stop VS process"
              }
            }
            # Do we still have the installer process? If so, close it.
            $installerProc = Get-Process -ErrorAction SilentlyContinue "${env:PRODUCT_NAME_BASE}"
            if ($installerProc) {
              $installerProc.CloseMainWindow()
              Sleep 10
              $installerProc = Get-Process -ErrorAction SilentlyContinue "${env:PRODUCT_NAME_BASE}"
              if ($installerProc) {
                # "Are you sure" prompt
                $installerProc.CloseMainWindow()
                Sleep 10
                $installerProc = Get-Process -ErrorAction SilentlyContinue "${env:PRODUCT_NAME_BASE}"
                if ($installerProc) {
                  $installerProc | Stop-Process -Force
                  $installerProc = Get-Process -ErrorAction SilentlyContinue "${env:PRODUCT_NAME_BASE}"
                  if ($installerProc) {
                    throw "Failed to stop installer process"
                  }
                }
              }
            }
          }
          $numInstallerCloseTries++
          if ($numInstallerCloseTries -eq $maxInstallerCloseTries) {
            throw "Reached max installer close tries; bailing out"
          }
        } While ($installerProc)
        echo "Installer finished"
        
        }
        
        echo "Testing msbuild:"
        & "${env:PRODUCT_BASE_INSTALL_PATH}\MSBuild.exe" /version
      
    - name: Install Visual C++ MFC MBCS Library for Visual Studio 2013
      env:
        PRODUCT_URL_BASE: https://download.microsoft.com/download/0/2/3/02389126-40A7-46FD-9D83-802454852703
        PRODUCT_NAME_BASE: vc_mbcsmfc
        PRODUCT_FULL_NAME: Visual C++ MFC MBCS Library for Visual Studio 2013
        PRODUCT_BASE_DLL_INSTALL_PATH: C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\redist\x86\Microsoft.VC120.MFC
        PRODUCT_BASE_EXE_INSTALL_PATH: C:\ProgramData\Package Cache\{91501789-1ec3-422d-9043-b1065a88d603}
      run: |
        if (1) { echo "Skipping step."; return }
        
        echo("Downloading ${env:PRODUCT_FULL_NAME}")
        mkdir ".\${env:PRODUCT_NAME_BASE}_files"
        $installerPath = "$pwd" + "\${env:PRODUCT_NAME_BASE}_files"
        Invoke-WebRequest "${env:PRODUCT_URL_BASE}/${env:PRODUCT_NAME_BASE}.exe" -OutFile "${installerPath}\${env:PRODUCT_NAME_BASE}.exe"
        
        echo("Verifying download integrity")
        # Based on https://devblogs.microsoft.com/scripting/reporting-on-digitally-signed-files-with-powershell/
        Function Expand-AuthenticodeSignature($AuthenticodeSignature)
        {
          $AuthenticodeSignature | Select-object -Property Path, `
            Status,StatusMessage,SignatureType, `
            @{Name=’SubjectName’;Expression={($_.SignerCertificate.Subject)}}, `
            @{Name=’SubjectIssuer’;Expression={($_.SignerCertificate.Issuer)}}, `
            @{Name=’SubjectSerialNumber’;Expression={($_.SignerCertificate.SerialNumber)}}, `
            @{Name=’SubjectNotBefore’;Expression={($_.SignerCertificate.NotBefore)}}, `
            @{Name=’SubjectNotAfter’;Expression={($_.SignerCertificate.NotAfter)}}, `
            @{Name=’SubjectThumbprint’;Expression={($_.SignerCertificate.ThumbPrint)}}, `
            @{Name=’TimeStamperName’;Expression={($_.SignerCertificate.Subject)}}, `
            @{Name=’TimeStamperIssuer’;Expression={($_.SignerCertificate.Issuer)}}, `
            @{Name=’TimeStamperSerialNumber’;Expression={($_.SignerCertificate.SerialNumber)}}, `
            @{Name=’TimeStamperNotBefore’;Expression={($_.SignerCertificate.NotBefore)}}, `
            @{Name=’TimeStamperNotAfter’;Expression={($_.SignerCertificate.NotAfter)}}, `
            @{Name=’TimeStamperThumbprint’;Expression={($_.SignerCertificate.ThumbPrint)}}
        }
        
        $productSig = Expand-AuthenticodeSignature -AuthenticodeSignature (Get-ChildItem "${installerPath}\${env:PRODUCT_NAME_BASE}.exe" | Get-AuthenticodeSignature)
        
        # Need to match this digital signature.
        $sigRequirements = @{
          "Status" = "Valid";
          "StatusMessage" = "Signature verified.";
          "SignatureType" = "Authenticode";
          "SubjectName" = "CN=Microsoft Corporation, OU=MOPR, O=Microsoft Corporation, L=Redmond, S=Washington, C=US";
        }
        
        foreach ($requirement in $sigRequirements.GetEnumerator()) {  
          $reqName = $requirement.Name
          $reqValue = $requirement.Value
          $sigValue = $productSig.$reqName
          if (-Not ($reqValue -eq $sigValue)) {
            throw "Digital signature mismatched value of $reqName (was `"${sigValue}`" but expected `"${reqValue}`")"
          }
        }
        echo "${env:PRODUCT_FULL_NAME} installer passed digital signature checks."
        
        echo("Installing ${env:PRODUCT_FULL_NAME}")
        echo "Launching `"${installerPath}\${env:PRODUCT_NAME_BASE}.exe`""
        & "${installerPath}\${env:PRODUCT_NAME_BASE}.exe"
        $wshell = New-Object -ComObject "WScript.Shell"
        echo "Waiting for installer"
        # Just wait until reasonably confident the installer should be ready
        Sleep 60
        # Grab the installer active window
        $installerWindowTitle = "${env:PRODUCT_FULL_NAME}"
        $wshell.AppActivate($installerWindowTitle)
        Sleep 1
        # Navigate the installer keypresses
        $wshell.SendKeys("`t ")
        Sleep 1
        $wshell.AppActivate($installerWindowTitle)
        Sleep 1
        $wshell.SendKeys("`t`t`n")
        
        # We're happy with MD5 because we only use it for file integrity checks; the installer
        # we're checking against has already passed a cert check.
        $integrityAlgo = "MD5"
        
        # Helper function for populating the reference array.
        function AddReference($hash, $path, $file)
        {
          $item = New-Object psobject
          $item | Add-Member -type NoteProperty -Name "Algorithm" -Value "$integrityAlgo"
          $item | Add-Member -type NoteProperty -Name "Hash" -Value "$hash"
          $item | Add-Member -type NoteProperty -Name "Path" -Value "${$path}\${file}"
          return $item
        }
        
        # Compare hashes to the reference, and return whether they are equal.
        function IsCompareEqualToReference($reference, $compare)
        {
          # Compare is allowed to be empty (ie. got nothing to compare), but the reference must exist.
          if (!$reference) {
            throw "Reference was null"
          }
          if (-Not $reference.Length -eq $compare.Length) {
            return $FALSE
          }
          $numMatches = 0
          foreach ($thisReference in $reference) {
            :inner foreach ($thisCompare in $compare) {
              if (-Not $thisReference.Path -eq $thisCompare.Path) {
                continue
              }
              if (-Not $thisReference.Algorithm -eq $thisCompare.Algorithm) {
                throw "Algorith mismatch ($thisReference.Algorithm vs. $thisCompare.Algorithm)"
              }
              if (-Not $thisReference.Hash -eq $thisCompare.Hash) {
                echo "Hash mismatch ($thisReference.Hash vs. $thisCompare.Hash)"
              } else {
                $numMatches++
              }
              break inner
            }
          }
          return ($numMatches -eq $reference.Length)
        }
        
        $installerWaitIntervalSeconds = 60
        
        # Try at most this many times with the above intervals, then give up and throw error.
        # Set to 0 to never give up (possible to go infinitely idle on installer failure state, bar runner timeout).
        $maxFails = 10
        
        # todo: fix me
        if (1) {
          echo "Skipping ProgramData exe path check"
        } else {
          # Array of reference file hashes we expect to find at PRODUCT_BASE_EXE_INSTALL_PATH on a finished installation.
          $exe_references = @()
          $exe_references += AddReference "84E1EF9C42095FA40E95602C9265C1A1" "${env:PRODUCT_BASE_EXE_INSTALL_PATH}" "state.rsm"
          $exe_references += AddReference "7110728D8A61F14FC56ADCBCC0FA32DE" "${env:PRODUCT_BASE_EXE_INSTALL_PATH}" "vc_mbcsmfc.exe"
          
          $exeInstallerFinished = $FALSE
          $numFails = 0
          Do {
            # Get the actual hashes we currently have.
            $compare = @()
            if (Test-Path -Path "${env:PRODUCT_BASE_EXE_INSTALL_PATH}") {
              Get-ChildItem -File "${env:PRODUCT_BASE_EXE_INSTALL_PATH}" | ForEach-Object {
                $compare += Get-FileHash -Algorithm "$integrityAlgo" $_.FullName
              }
            } else {
              echo "Not yet path at `"${env:PRODUCT_BASE_EXE_INSTALL_PATH}`""
            }
            
            $exeInstallerFinished = (IsCompareEqualToReference $exe_references $compare)
            if (-not($exeInstallerFinished)) {
              $numFails++
              if ($numFails -eq $maxFails) {
                throw "Reached max wait wait fails; timing out (the installer has probably failed)"
              }
              echo "Waiting for exe part of installer to finish"
              Sleep $installerWaitIntervalSeconds
            }
          } While (-not($exeInstallerFinished))
          Sleep $installerWaitIntervalSeconds
        }
        
        # Array of reference file hashes we expect to find at PRODUCT_BASE_DLL_INSTALL_PATH on a finished installation.
        $dll_references = @()
        $dll_references += AddReference "DF9A5545501A2442CA54C73C6F4DE827" "${env:PRODUCT_BASE_DLL_INSTALL_PATH}" "mfc120.dll"
        $dll_references += AddReference "F4F2A4C459DD3AA22DD3984D13B15746" "${env:PRODUCT_BASE_DLL_INSTALL_PATH}" "mfc120u.dll"
        $dll_references += AddReference "832CC047743469082FAE5E3CC830CD8C" "${env:PRODUCT_BASE_DLL_INSTALL_PATH}" "mfcm120.dll"
        $dll_references += AddReference "AB8766067BB26D7AB4061B0E4FC7D2C0" "${env:PRODUCT_BASE_DLL_INSTALL_PATH}" "mfcm120u.dll"
        
        $dllInstallerFinished = $FALSE
        $numFails = 0
        Do {
          # Get the actual hashes we currently have.
          $compare = @()
          if (Test-Path -Path "${env:PRODUCT_BASE_DLL_INSTALL_PATH}") {
            Get-ChildItem -File "${env:PRODUCT_BASE_DLL_INSTALL_PATH}" | ForEach-Object {
              $compare += Get-FileHash -Algorithm "$integrityAlgo" $_.FullName
            }
          } else {
            echo "Not yet path at `"${env:PRODUCT_BASE_DLL_INSTALL_PATH}`""
          }
          
          $dllInstallerFinished = (IsCompareEqualToReference $dll_references $compare)
          if (-Not($dllInstallerFinished)) {
            $numFails++
            if ($numFails -eq $maxFails) {
              throw "Reached max wait time fails; timing out (the installer has probably failed)"
            }
            echo "Waiting for dll part of installer to finish"
            Sleep $installerWaitIntervalSeconds
          }
        } While (-Not($dllInstallerFinished))
        Sleep $installerWaitIntervalSeconds
        
        # Wait for IO data to complete before continuing.
        $numFails = 0
        $maxFails = 10
        $numIOSuccesses = 0
        $numIOSuccessesToContinue = 10
        Do {
          $perfProc = Get-CimInstance Win32_PerfFormattedData_PerfProc_Process | ? { $_.name -eq "${env:PRODUCT_NAME_BASE}" }
          if (!$perfProc) {
            throw "Couldn't get ${env:PRODUCT_NAME_BASE} perfproc"
          }
          if (-not($perfProc.IODataOperationsPersec -eq 0)) {
            $numFails++
            if ($numFails -eq $maxFails) {
              throw "IO check reached max wait time fails; aborting"
            }
            echo "Waiting for data IO to finish"
            Sleep $installerWaitIntervalSeconds
          } else {
            $numIOSuccesses++
          }
        } While ((-not($perfProc.IODataOperationsPersec -eq 0)) -and ($numIOSuccesses -eq $numIOSuccessesToContinue))
        echo "IO data finished"
        
        # Installer exit sequence.
        $wshell.AppActivate($installerWindowTitle)
        Sleep 1
        $wshell.SendKeys("`t ")
        
        # Ask to close the installer.
        echo "Preparing to close the installer"
        $installerProc = Get-Process -ErrorAction SilentlyContinue "${env:PRODUCT_NAME_BASE}"
        if ($installerProc) {
          $installerProc.CloseMainWindow()
          Sleep 5
          $installerProc = Get-Process -ErrorAction SilentlyContinue "${env:PRODUCT_NAME_BASE}"
          if ($installerProc) {
            # If it still hasn't closed, do a forceful close.
            $installerProc | Stop-Process -Force
            Sleep 10
             $installerProc = Get-Process -ErrorAction SilentlyContinue "${env:PRODUCT_NAME_BASE}"
            if ($installerProc) {
              throw "Unable to kill installer proc"
            }
          }
        }
        echo "Installer finished"
        
    - name: Build all
      env:
        DEVENV_COM: C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\IDE\devenv.com
        MSBUILD_BIN: C:\Program Files (x86)\MSBuild\12.0\Bin\MSBuild.exe
      run: |
        if (1) { echo "Skipping step."; return }
        
        # Need to cd here because the batch script calls tools relative to this dir position.
        cd "${env:GITHUB_WORKSPACE}\mp\src"
        
        # If we fail with the following error message, VS setup has most likely failed in a previous runner step:
        # "ERROR: Unable to find RegKey for .vcproj or .vcxproj files in solutions."
        & ".\createallprojects.bat"
      
        $compileErrLog = "compile_errors.log"
        
        # If the devenv binary doesn't exist, the VS setup has most likely failed in a previous runner step.
        # & "${env:DEVENV_COM}" .\everything.sln /Build Release`|Win32 /Out $compileErrLog
        
        & "${env:MSBUILD_BIN}" .\everything.sln /nologo /property:Configuration=Release /target:"Clean;Build" /verbosity:detailed
        
        # if (Test-Path -Path ".\${compileErrLog}") {
        #   echo "Compile error log was found; dumping:"
        #   Get-Content ".\${compileErrLog}"
        #   throw "Encountered compile error(s)"
        # }
        echo "Post-compile"
        
        echo "`nListing build products:"
        cd "${env:GITHUB_WORKSPACE}\mp\game\neo"
        ls
        cd ".\bin"
        ls
        
    - uses: microsoft/setup-msbuild@v1
    - name: Build
      run: |
        cd "${env:GITHUB_WORKSPACE}\mp\src"
        msbuild everything.sln /m /nologo /p:Configuration=Release /t:"Clean;Build"
        echo "`nListing build products:"
        cd "${env:GITHUB_WORKSPACE}\mp\game\neo"
        ls
        cd ".\bin"
        ls
