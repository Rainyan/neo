name: CI

on:
  push:
    branches: [ build_test_win ]
  pull_request:
    branches: [ build_test_win ]
    types: [ synchronize ]

jobs:
  build:
    strategy:
      matrix:
        os: [ windows-latest ]

    runs-on: ${{ matrix.os }}
    
    steps:
    # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
    - uses: actions/checkout@v2
    #- uses: ilammy/msvc-dev-cmd@v1
    #  with:
    #    arch: 'x86'
    #    toolset: '12.0'
      
    - name: Install Microsoft Speech SDK 5.1
      #working-directory: .\speechsdk
      env:
        SPEECH_SDK_URL: https://download.microsoft.com/download/B/4/3/B4314928-7B71-4336-9DE7-6FA4CF00B7B3/SpeechSDK51.exe
        SPEECH_SDK_NAME: SpeechSDK51
        SPEECH_SDK_PRODUCT_NAME: Microsoft Speech SDK 5.1
        SPEECH_SDK_CONTAINED_INSTALLER: Microsoft Speech SDK 5.1.msi
        SPEECH_SDK_INSTALL_LOCATION: C:\Program Files (x86)\Microsoft Speech SDK 5.1
        SPEECH_SDK_PATCH_URL: https://gist.githubusercontent.com/Rainyan/6ac519c7257b54f45546c0864adc1cb0/raw/9c8444790c53365a3143accb26851cb3dbb574ac
        SPEECH_SDK_PATCH_FILE: fix_speechsdk_syntax.patch
      run: |        
        echo("Downloading ${env:SPEECH_SDK_PRODUCT_NAME}...")
        Invoke-WebRequest ${env:SPEECH_SDK_URL} -OutFile ".\${env:SPEECH_SDK_NAME}.exe"

        echo("Verifying download integrity...")
        
        # Based on https://devblogs.microsoft.com/scripting/reporting-on-digitally-signed-files-with-powershell/
        Function Expand-AuthenticodeSignature($AuthenticodeSignature)
        {
          $AuthenticodeSignature | Select-object -Property Path, `
            Status,StatusMessage,SignatureType, `
            @{Name=’SubjectName’;Expression={($_.SignerCertificate.Subject)}}, `
            @{Name=’SubjectIssuer’;Expression={($_.SignerCertificate.Issuer)}}, `
            @{Name=’SubjectSerialNumber’;Expression={($_.SignerCertificate.SerialNumber)}}, `
            @{Name=’SubjectNotBefore’;Expression={($_.SignerCertificate.NotBefore)}}, `
            @{Name=’SubjectNotAfter’;Expression={($_.SignerCertificate.NotAfter)}}, `
            @{Name=’SubjectThumbprint’;Expression={($_.SignerCertificate.ThumbPrint)}}, `
            @{Name=’TimeStamperName’;Expression={($_.SignerCertificate.Subject)}}, `
            @{Name=’TimeStamperIssuer’;Expression={($_.SignerCertificate.Issuer)}}, `
            @{Name=’TimeStamperSerialNumber’;Expression={($_.SignerCertificate.SerialNumber)}}, `
            @{Name=’TimeStamperNotBefore’;Expression={($_.SignerCertificate.NotBefore)}}, `
            @{Name=’TimeStamperNotAfter’;Expression={($_.SignerCertificate.NotAfter)}}, `
            @{Name=’TimeStamperThumbprint’;Expression={($_.SignerCertificate.ThumbPrint)}}
        }
        $speechSdkSig = Expand-AuthenticodeSignature -AuthenticodeSignature (Get-ChildItem "${env:SPEECH_SDK_NAME}.exe" | Get-AuthenticodeSignature)

        # Need to match this digital signature.
        $sigRequirements = @{
          "Status" = "Valid";
          "StatusMessage" = "Signature verified.";
          "SignatureType" = "Authenticode";
          "SubjectName" = "CN=Microsoft Corporation, OU=Copyright (c) 2001 Microsoft Corp., O=Microsoft Corporation, L=Redmond, S=Washington, C=US";
        }

        foreach ($requirement in $sigRequirements.GetEnumerator()) {	
          $reqName = $requirement.Name
          $reqValue = $requirement.Value
          $sigValue = $speechSdkSig.$reqName
          if (-Not ($reqValue -eq $sigValue)) {
            throw "Digital signature mismatched value of $reqName (was `"$sigValue`" but expected `"$reqValue`")"
          }
        }
        echo "File ${env:SPEECH_SDK_PRODUCT_NAME} passed digital signature checks."
        
        echo("Unarchiving ${env:SPEECH_SDK_PRODUCT_NAME} installer...")
        # We can interpret this self-extracting executable as a zip archive.
        Rename-Item -Path ".\${env:SPEECH_SDK_NAME}.exe" -NewName ".\${env:SPEECH_SDK_NAME}.zip"
        $unZipDir = "$pwd" + "\${env:SPEECH_SDK_NAME}_files"
        Expand-Archive -Path ".\${env:SPEECH_SDK_NAME}.zip" -DestinationPath "${unZipDir}"
        
        echo("Installing ${env:SPEECH_SDK_PRODUCT_NAME}...")
        $logFile = "msiexec.log"
        echo "Installer full path: `"${unZipDir}\${env:SPEECH_SDK_CONTAINED_INSTALLER}`""
        echo "Log full path: `"${unZipDir}\${logFile}`""
        # Pipe to null to wait for installation to finish before continuing.
        msiexec /i "${unZipDir}\${env:SPEECH_SDK_CONTAINED_INSTALLER}" /norestart /passive /l*v "${unZipDir}\${logFile}" | Out-Null
        # Check if the install was successful by parsing the msiexec log file.
        $msiLog = Get-Content "${unZipDir}\${logFile}"
        # Looking for a line with this pattern.
        $msiLogCompletionLine = "Windows Installer installed the product."
        $msiResultLine = Select-String -Path "${unZipDir}\${logFile}" -Pattern $msiLogCompletionLine
        if (!$msiResultLine) {
          throw "Installer log was missing the required pattern: `"${msiLogCompletionLine}`""
        }
        # Line should end with this pattern specifying the MSI exit code 0.
        $msiSuccessPattern = ": 0."
        $msiResultStr = $msiResultLine.ToString().Trim()
        $msiResultSubstr = $msiResultStr.Substring($msiResultStr.Length - $msiSuccessPattern.Length)
        $msiInstallSuccess = ($msiResultSubstr -eq $msiSuccessPattern)
        if (!$msiInstallSuccess) {
          throw "MSI install success != true; exitcode substring returned ${msiResultSubstr} (this may not be the actual full exit code)."
        } else {
          echo "${env:SPEECH_SDK_PRODUCT_NAME} installation was successful."
        }
        
        echo "Correcting ${env:SPEECH_SDK_PRODUCT_NAME} include syntax..."
        
        $fixupCmd = "cd `"${env:SPEECH_SDK_INSTALL_LOCATION}`";ls;Invoke-WebRequest `"${env:SPEECH_SDK_PATCH_URL}/${env:SPEECH_SDK_PATCH_FILE}`" -OutFile `".\${env:SPEECH_SDK_PATCH_FILE}`";git apply --check --verbose --summary `".\${env:SPEECH_SDK_PATCH_FILE}`";git apply `".\${env:SPEECH_SDK_PATCH_FILE}`""
        echo "Fixup cmd:"
        echo "${fixupCmd}"
        
        if (-Not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
          echo "Was non-elevated ps"
        } else {
          echo "Was elevated ps"
        }
        
        Start-Process PowerShell -Verb RunAs "-NoProfile -ExecutionPolicy Bypass -Command `"$fixupCmd`"" | Out-Null
        cd "${env:SPEECH_SDK_INSTALL_LOCATION}"
        ls
        git apply --check --verbose --summary ".\${env:SPEECH_SDK_PATCH_FILE}"

