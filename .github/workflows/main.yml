name: CI

on:
  push:
    branches: [ build_test_win ]
  pull_request:
    branches: [ build_test_win ]
    types: [ synchronize ]

jobs:
  build:
    strategy:
      matrix:
        os: [ windows-latest ]

    runs-on: ${{ matrix.os }}
    
    steps:
    # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
    - uses: actions/checkout@v2
            
    - name: Install Microsoft Speech SDK 5.1
      env:
        SPEECH_SDK_URL: https://download.microsoft.com/download/B/4/3/B4314928-7B71-4336-9DE7-6FA4CF00B7B3/SpeechSDK51.exe
        SPEECH_SDK_NAME: SpeechSDK51
        SPEECH_SDK_PRODUCT_NAME: Microsoft Speech SDK 5.1
        SPEECH_SDK_CONTAINED_INSTALLER: Microsoft Speech SDK 5.1.msi
        SPEECH_SDK_INSTALL_LOCATION: C:\Program Files (x86)\Microsoft Speech SDK 5.1
        SPEECH_SDK_PATCH_URL: https://gist.githubusercontent.com/Rainyan/6ac519c7257b54f45546c0864adc1cb0/raw/9c8444790c53365a3143accb26851cb3dbb574ac
        SPEECH_SDK_PATCH_FILE: fix_speechsdk_syntax.patch
      run: |        
        echo("Downloading ${env:SPEECH_SDK_PRODUCT_NAME}")
        Invoke-WebRequest ${env:SPEECH_SDK_URL} -OutFile ".\${env:SPEECH_SDK_NAME}.exe"
        
        echo("Verifying download integrity")
        # Based on https://devblogs.microsoft.com/scripting/reporting-on-digitally-signed-files-with-powershell/
        Function Expand-AuthenticodeSignature($AuthenticodeSignature)
        {
          $AuthenticodeSignature | Select-object -Property Path, `
            Status,StatusMessage,SignatureType, `
            @{Name=’SubjectName’;Expression={($_.SignerCertificate.Subject)}}, `
            @{Name=’SubjectIssuer’;Expression={($_.SignerCertificate.Issuer)}}, `
            @{Name=’SubjectSerialNumber’;Expression={($_.SignerCertificate.SerialNumber)}}, `
            @{Name=’SubjectNotBefore’;Expression={($_.SignerCertificate.NotBefore)}}, `
            @{Name=’SubjectNotAfter’;Expression={($_.SignerCertificate.NotAfter)}}, `
            @{Name=’SubjectThumbprint’;Expression={($_.SignerCertificate.ThumbPrint)}}, `
            @{Name=’TimeStamperName’;Expression={($_.SignerCertificate.Subject)}}, `
            @{Name=’TimeStamperIssuer’;Expression={($_.SignerCertificate.Issuer)}}, `
            @{Name=’TimeStamperSerialNumber’;Expression={($_.SignerCertificate.SerialNumber)}}, `
            @{Name=’TimeStamperNotBefore’;Expression={($_.SignerCertificate.NotBefore)}}, `
            @{Name=’TimeStamperNotAfter’;Expression={($_.SignerCertificate.NotAfter)}}, `
            @{Name=’TimeStamperThumbprint’;Expression={($_.SignerCertificate.ThumbPrint)}}
        }
        
        $speechSdkSig = Expand-AuthenticodeSignature -AuthenticodeSignature (Get-ChildItem "${env:SPEECH_SDK_NAME}.exe" | Get-AuthenticodeSignature)

        # Need to match this digital signature.
        $sigRequirements = @{
          "Status" = "Valid";
          "StatusMessage" = "Signature verified.";
          "SignatureType" = "Authenticode";
          "SubjectName" = "CN=Microsoft Corporation, OU=Copyright (c) 2001 Microsoft Corp., O=Microsoft Corporation, L=Redmond, S=Washington, C=US";
        }

        foreach ($requirement in $sigRequirements.GetEnumerator()) {	
          $reqName = $requirement.Name
          $reqValue = $requirement.Value
          $sigValue = $speechSdkSig.$reqName
          if (-Not ($reqValue -eq $sigValue)) {
            throw "Digital signature mismatched value of $reqName (was `"${sigValue}`" but expected `"${reqValue}`")"
          }
        }
        echo "${env:SPEECH_SDK_PRODUCT_NAME} passed digital signature checks."
        
        echo("Unarchiving ${env:SPEECH_SDK_PRODUCT_NAME} installer")
        # We can interpret this self-extracting executable as a zip archive.
        Rename-Item -Path ".\${env:SPEECH_SDK_NAME}.exe" -NewName ".\${env:SPEECH_SDK_NAME}.zip"
        $unZipDir = "$pwd" + "\${env:SPEECH_SDK_NAME}_files"
        Expand-Archive -Path ".\${env:SPEECH_SDK_NAME}.zip" -DestinationPath "${unZipDir}"
        
        echo("Installing ${env:SPEECH_SDK_PRODUCT_NAME}")
        $logFile = "msiexec.log"
        echo "Installer full path: `"${unZipDir}\${env:SPEECH_SDK_CONTAINED_INSTALLER}`""
        echo "Log full path: `"${unZipDir}\${logFile}`""
        # Pipe to null to wait for installation to finish before continuing.
        msiexec /i "${unZipDir}\${env:SPEECH_SDK_CONTAINED_INSTALLER}" /norestart /passive /l*v "${unZipDir}\${logFile}" | Out-Null
        
        # Check if the install was successful by parsing the msiexec log file.
        $msiLog = Get-Content "${unZipDir}\${logFile}"
        # Looking for a line with this pattern.
        $msiLogCompletionLine = "Windows Installer installed the product."
        $msiResultLine = Select-String -Path "${unZipDir}\${logFile}" -Pattern $msiLogCompletionLine
        if (!$msiResultLine) {
          throw "MSI log was missing the required pattern: `"${msiLogCompletionLine}`""
        }
        # Line should end with this pattern specifying the MSI exit code 0.
        $msiSuccessPattern = ": 0."
        $msiResultStr = $msiResultLine.ToString().Trim()
        $msiResultSubstr = $msiResultStr.Substring($msiResultStr.Length - $msiSuccessPattern.Length)
        $msiInstallSuccess = ($msiResultSubstr -eq $msiSuccessPattern)
        if (!$msiInstallSuccess) {
          echo "Failed to find the required pattern; dumping log of `"${installerFullPath}\${logFile}`":"
          Get-Content "${installerFullPath}\${logFile}"
          throw "MSI success != true; exitcode substring returned ${msiResultSubstr} (this may not be the actual full exit code)"
        } else {
          echo "${env:SPEECH_SDK_PRODUCT_NAME} MSI was successful"
        }
        
        echo "Correcting ${env:SPEECH_SDK_PRODUCT_NAME} include syntax"
        cd "${env:SPEECH_SDK_INSTALL_LOCATION}"
        Invoke-WebRequest "${env:SPEECH_SDK_PATCH_URL}/${env:SPEECH_SDK_PATCH_FILE}" -OutFile ".\${env:SPEECH_SDK_PATCH_FILE}"
        git apply --check --verbose --summary ".\${env:SPEECH_SDK_PATCH_FILE}"
        git apply ".\${env:SPEECH_SDK_PATCH_FILE}"
        
    - name: Install Microsoft Visual Studio Community 2013 with Update 5
      env:
        PRODUCT_URL_BASE: https://download.microsoft.com/download/A/A/D/AAD1AA11-FF9A-4B3C-8601-054E89260B78
        PRODUCT_NAME_BASE: vs_community
        PRODUCT_FULL_NAME: Microsoft Visual Studio Community 2013 with Update 5
      run: |
        echo("Downloading ${env:PRODUCT_FULL_NAME}")
        mkdir ".\${env:PRODUCT_NAME_BASE}_files"
        $installerPath = "$pwd" + "\${env:PRODUCT_NAME_BASE}_files\${env:PRODUCT_NAME_BASE}.exe"
        Invoke-WebRequest "${env:PRODUCT_URL_BASE}/${env:PRODUCT_NAME_BASE}.exe" -OutFile "${installerPath}"
        
        echo("Verifying download integrity")
        # Based on https://devblogs.microsoft.com/scripting/reporting-on-digitally-signed-files-with-powershell/
        Function Expand-AuthenticodeSignature($AuthenticodeSignature)
        {
          $AuthenticodeSignature | Select-object -Property Path, `
            Status,StatusMessage,SignatureType, `
            @{Name=’SubjectName’;Expression={($_.SignerCertificate.Subject)}}, `
            @{Name=’SubjectIssuer’;Expression={($_.SignerCertificate.Issuer)}}, `
            @{Name=’SubjectSerialNumber’;Expression={($_.SignerCertificate.SerialNumber)}}, `
            @{Name=’SubjectNotBefore’;Expression={($_.SignerCertificate.NotBefore)}}, `
            @{Name=’SubjectNotAfter’;Expression={($_.SignerCertificate.NotAfter)}}, `
            @{Name=’SubjectThumbprint’;Expression={($_.SignerCertificate.ThumbPrint)}}, `
            @{Name=’TimeStamperName’;Expression={($_.SignerCertificate.Subject)}}, `
            @{Name=’TimeStamperIssuer’;Expression={($_.SignerCertificate.Issuer)}}, `
            @{Name=’TimeStamperSerialNumber’;Expression={($_.SignerCertificate.SerialNumber)}}, `
            @{Name=’TimeStamperNotBefore’;Expression={($_.SignerCertificate.NotBefore)}}, `
            @{Name=’TimeStamperNotAfter’;Expression={($_.SignerCertificate.NotAfter)}}, `
            @{Name=’TimeStamperThumbprint’;Expression={($_.SignerCertificate.ThumbPrint)}}
        }
        
        $productSig = Expand-AuthenticodeSignature -AuthenticodeSignature (Get-ChildItem "${installerPath}" | Get-AuthenticodeSignature)
        
        # Need to match this digital signature.
        $sigRequirements = @{
          "Status" = "Valid";
          "StatusMessage" = "Signature verified.";
          "SignatureType" = "Authenticode";
          "SubjectName" = "CN=Microsoft Corporation, OU=MOPR, O=Microsoft Corporation, L=Redmond, S=Washington, C=US";
        }
        
        foreach ($requirement in $sigRequirements.GetEnumerator()) {	
          $reqName = $requirement.Name
          $reqValue = $requirement.Value
          $sigValue = $productSig.$reqName
          if (-Not ($reqValue -eq $sigValue)) {
            throw "Digital signature mismatched value of $reqName (was `"${sigValue}`" but expected `"${reqValue}`")"
          }
        }
        echo "${env:PRODUCT_FULL_NAME} installer passed digital signature checks."
        
        echo("Installing ${env:PRODUCT_FULL_NAME}")
        $logFile = "msiexec.log"
        echo "Installer full path: `"${installerPath}\`""
        echo "Log full path: `"${installerPath}\${logFile}`""
        # Pipe to null to wait for installation to finish before continuing.
        msiexec /i "${installerPath}\${env:PRODUCT_NAME_BASE}.exe" /norestart /passive /l*v "${installerPath}\${logFile}" | Out-Null
        
        # Check if the install was successful by parsing the msiexec log file.
        # Looking for a line with this pattern.
        $msiLogCompletionLine = "Windows Installer installed the product."
        $msiResultLine = Select-String -Path "${installerPath}\${logFile}" -Pattern $msiLogCompletionLine
        if (!$msiResultLine) {
          echo "Failed to find the required pattern; dumping log of `"${installerFullPath}\${logFile}`":"
          Get-Content "${installerPath}\${logFile}"
          throw "${env:PRODUCT_FULL_NAME} MSI log was missing the required pattern: `"${msiLogCompletionLine}`""
        }
        # Line should end with this pattern specifying the MSI exit code 0.
        $msiSuccessPattern = ": 0."
        $msiResultStr = $msiResultLine.ToString().Trim()
        $msiResultSubstr = $msiResultStr.Substring($msiResultStr.Length - $msiSuccessPattern.Length)
        $msiInstallSuccess = ($msiResultSubstr -eq $msiSuccessPattern)
        if (!$msiInstallSuccess) {
          throw "${env:PRODUCT_FULL_NAME} MSI success != true; exitcode substring returned ${msiResultSubstr} (this may not be the actual full exit code)"
        } else {
          echo "${env:PRODUCT_FULL_NAME} MSI was successful"
        }
      
